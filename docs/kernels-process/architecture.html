<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Conceptos de Arquitectura de Computadoras :: Conceptos de Sistemas Operativos</title>
    <link rel="canonical" href="https://ninjascl.github.io/sistemas-operativos/kernels-process/architecture.html">
    <link rel="prev" href="../introduction/roles.html">
    <link rel="next" href="process.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../_/css/site.css">
    <link rel="stylesheet" href="../_/js/vendor/styles/monokai.css">  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://ninjascl.github.io/sistemas-operativos">Conceptos de Sistemas Operativos</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Buscar">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <!--
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
    -->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ROOT" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Conceptos de Sistemas Operativos</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introducción</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../introduction/introduction.html">Introducción a los Sistemas Operativos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../introduction/history.html">Historia de los Sistemas Operativos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../introduction/roles.html">¿Qué Roles Tiene un Sistema Operativo?</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Kernel y Procesos</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="architecture.html">Conceptos de Arquitectura de Computadoras</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="process.html">Procesos</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Programación en Ada</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/about.html">Introducción al lenguaje Ada</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/history.html">Historia del lenguaje Ada</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/hello.html">Hola mundo</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/sqrt.html">Raíz Cuadrada</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/temperature.html">Conversor de Temperatura</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/arrays.html">Arreglos y Listas</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/args.html">Argumentos de Línea de Comandos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/strings.html">Strings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/guess.html">Adivina el Número</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ada-basics/process.html">Gatillar Procesos</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Proyectos</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../projects/project1.html">Proyecto 1: Minishell</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../bibliography.html">Bibliografía</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Conceptos de Sistemas Operativos</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Conceptos de Sistemas Operativos</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Conceptos de Sistemas Operativos</a></li>
    <li>Kernel y Procesos</li>
    <li><a href="architecture.html">Conceptos de Arquitectura de Computadoras</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="file:///antora/./modules/kernels-process/pages/architecture.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contenidos" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Conceptos de Arquitectura de Computadoras</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Para comprender mejor los conceptos de procesos e hilos, se debe dar un pequeño
repaso a conceptos de arquitectura de computadoras y cómo un programa es ejecutado
en el procesador.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="por-qué-el-tipo-y-tamaño-de-las-variables-es-importante"><a class="anchor" href="#por-qué-el-tipo-y-tamaño-de-las-variables-es-importante"></a>¿Por qué el tipo y tamaño de las variables es importante?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En la actualidad existen lenguajes como <em>Javascript</em>, <em>Python</em>, <em>Elixir</em>, entre otros, donde no es necesario ser explícito
para establecer el tipo de cada variable ni el tamaño que estas usan
en memoria, ya que el intérprete de cada lenguaje es quien toma esa decisión.</p>
</div>
<div class="paragraph">
<p>Al momento de utilizar lenguajes de programación de sistemas como
<em>C</em>, <em>Ada</em> o <em>Rust</em>, entre otros, se debe ser más explícito. Estos
lenguajes obligan a declarar las variables incluyendo su tipo y permiten
mayor granuralidad en el manejo de la memoria. A diferencia de los lenguajes interpretados donde solamente puede ser necesario un tipo llamado <code>"Number"</code>, en los lenguajes de sistemas existe la diferenciación
entre enteros, punto flotante y punto fijo, además una granularización
sobre cuánta memoria (8 bit, 16bit, 32bit, 64bit) cada tipo utilizará
para almacenar los datos. Incluso estos lenguajes pueden permitir especificar si el número es positivo o negativo, aumentando el control sobre el uso de la memoria.</p>
</div>
<div class="paragraph">
<p>La memoria de un computador es finita y el propósito de estos tipos
es especificar exactamente cuánto espacio en memoria es necesario
para representar la información que el programa utiliza.</p>
</div>
<div class="paragraph">
<p>Un bit es la unidad mínima de valor que puede tener dos estados 0 y 1. El computador representa los datos en una secuencia de ocho bits llamada byte (00000000 a 11111111 en binario, 00 a FF en hexadecimal, 0 a 255 en decimal). Es decir que un byte (255 valores posibles) es el mínimo de bits usado para almacenar algo y por eso es que se utilizan múltiplos de ocho (8, 16, 32, 64) para representar los números.</p>
</div>
<div class="paragraph">
<p>El programador al delegar la gestión de memoria a un lenguaje interpretado, pierde la capacidad de optimizar la memoria usada, provocando que muchas veces un lenguaje interpretado utilice más memoria de la necesaria para la misma operación que en un lenguaje de sistemas.
Los lenguajes interpretados deben almacenar el dato y metadatos (tags) asociados para poder realizar su gestión de tipos y memoria interna. Esto no solo aumenta la cantidad de memoria necesaria, también aumenta la cantidad de operaciones (leer, escribir, comparar) que la CPU debe realizar. El intérprete entonces debe ejecutar todos esos pasos adicionales no relacionados al código del programador, lo que en contraste con lenguajes compilados no es necesario debido a que se ha dado la información de tipos y memoria con antelación.</p>
</div>
<div class="paragraph">
<p>El compilador de un lenguaje de sistemas puede generar código máquina más eficiente, sin necesidad de validaciones adicionales. Ésta es una de las principales razones por la que los lenguajes de tipado dinámico son mucho más lentos y requieren mayor cantidad de recursos (memoria, CPU) que los lenguajes de sistemas. Sin embargo, los lenguajes de sistemas requieren de mayor cautela y rigurosidad en su programación, por ejemplo un arreglo que necesite de una cantidad variable de elementos (crecer o reducir su cantidad de elementos dinámicamente) debe usar estrategias de gestión de memoria (regiones de memoria como Heap y Stack, tamaño del arreglo).</p>
</div>
<iframe width="100%" height="415" src="https://www.youtube.com/embed/hwyRnHA54lI?si=vnQ1Pq2tyQXWGG6e" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
</div>
<div class="sect1">
<h2 id="componentes-de-una-cpu"><a class="anchor" href="#componentes-de-una-cpu"></a>Componentes de una CPU</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Una <em>CPU</em>, o unidad central de procesamiento, es un componente de hardware y la unidad computacional central de un servidor. La <em>CPU</em> es el componente principal que procesa las señales y hace posible la computación. Actúa como el cerebro de cualquier dispositivo de computación. Obtiene instrucciones de la memoria, realiza las tareas necesarias y envía la salida a la memoria. Maneja todo tipo de tareas de computación necesarias para que el sistema operativo y las aplicaciones se ejecuten. (AWS, 2024).</p>
</div>
<div class="sect2">
<h3 id="reloj-clock"><a class="anchor" href="#reloj-clock"></a>Reloj (Clock)</h3>
<div class="paragraph">
<p>La <em>CPU</em> se basa en una señal de reloj para sincronizar sus operaciones internas. El reloj genera un pulso constante a una frecuencia específica y estos ciclos de reloj coordinan las operaciones de la <em>CPU</em>. La velocidad del reloj se mide en hercios (Hz) y determina cuántas instrucciones puede ejecutar la <em>CPU</em> por segundo. Las <em>CPU</em> modernas tienen velocidades de reloj variables que se ajustan en función de la carga de trabajo para equilibrar el rendimiento y el consumo de energía. (AWS, 2024).</p>
</div>
<div class="paragraph">
<p>Por ejemplo el reloj necesario para el famoso procesador <a href="https://github.com/maarten-pennings/6502/blob/master/1clock/README.md">6502 requiere de 1Mhz</a> (Usado en sistemas como la Atari, Nintendo y Apple II). Mientras que procesadores modernos como el <a href="https://www.intel.com/content/www/us/en/products/sku/237504/intel-core-i9-processor-14900ks-36m-cache-up-to-6-20-ghz/specifications.html">i9 pueden llegar a los 6.20 Ghz</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="registros-registers"><a class="anchor" href="#registros-registers"></a>Registros (Registers)</h3>
<div class="paragraph">
<p>Los registros son pequeñas ubicaciones de almacenamiento de memoria de alta velocidad dentro de la <em>CPU</em>. Contienen datos en los que la <em>CPU</em> está trabajando en ese momento y facilitan un acceso rápido a los datos. Las <em>CPU</em> tienen varios tipos de registros, como:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Registros de uso general que contienen datos operativos</p>
</li>
<li>
<p>Registros de instrucciones que contienen la instrucción actual que se está procesando</p>
</li>
<li>
<p>Un contador de programas que contiene la dirección de memoria de la siguiente instrucción que se va a recuperar</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los registros proporcionan tiempos de acceso más rápidos que otros niveles de memoria, como la RAM o la memoria caché (AWS, 2024).</p>
</div>
<div class="paragraph">
<p>En palabras simples, los registros son como variables usadas por el procesador que guardan información necesaria para las tareas a realizar por el mismo, al estar más cercanas al <em>CPU</em> tienen mayor velocidad que la memoria o cache. Algunos registros pueden ser de uso general mientras que otros son de un uso específico como el <em>Program Counter</em>.</p>
</div>
<div class="sect3">
<h4 id="contador-de-programa-program-counter"><a class="anchor" href="#contador-de-programa-program-counter"></a>Contador de Programa (Program Counter)</h4>
<div class="paragraph">
<p>El contador de programa, también conocido como puntero de instrucción o simplemente <code>PC</code>, es un componente fundamental de la unidad central de proceso (CPU) de un computador. Es un registro especial que lleva la cuenta de la dirección de memoria de la siguiente instrucción a ejecutar en un programa (Lenovo, s.f).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pila-stack"><a class="anchor" href="#pila-stack"></a>Pila (Stack)</h3>
<div class="paragraph">
<p>Una pila (stack) es una estructura de datos donde el último elemento en entrar es el primero en salir (Last in - first out, LIFO). Es como una pila de platos; No se puede quitar una plato del medio sin interrumpir toda la pila. (Lenovo, s.f). En la informática una pila tiene un tamaño máximo y si se excede ocurre lo que se conoce como "saturación de pila" (stack overflow).</p>
</div>
<div class="paragraph">
<p>En términos de procesadores la pila corresponde a la "pila de ejecución" (execution stack), también conocida como "pila de programa" (program stack), incluso como "pila de hardware" (hardware stack). Cuando se ejecuta un programa, técnicamente no hay limitaciones donde se escribe dentro de la memoria, si bien se puede definir el tamaño, la ubicación en memoria puede ser totalmente aleatoria y arbitraria. Pero hacer esto es ineficiente, provocando que exista mucho espacio desperdiciado.</p>
</div>
<div class="paragraph">
<p>El sistema operativo es el intermediario entre los programas y el hardware. Cuando un programa se ejecuta, el sistema operativo no permite que este almacene los datos en cualquier parte de la memoria, debido a que otros programas podrían estar utilizando ese espacio. El programa debe solicitar al sistema operativo un espacio de memoria y este buscará el espacio disponible para que el programa escriba y lea sus datos.</p>
</div>
<div class="paragraph">
<p>Si un programa intenta leer un espacio de memoria que esta fuera de los límites que el sistema operativo le otorgó, el sistema operativo tiene la facultad de terminar el programa (por razones de seguridad), dándo origen a los errores conocidos como "Segmentation Fault, Core Dumped". Es por este motivo que el sistema operativo asigna la memoria en bloques (memory chunk) que los programas pueden usar para leer y escribir.</p>
</div>
<div class="paragraph">
<p>Si un programa no administra bien su memoria y almacena sus datos de forma desordenada, podría necesitar más bloques de memoria. Eventualmente esto podría causar lo que se conoce como "Fragmentación Externa" (external fragmentation) donde existe memoria libre suficiente, pero no se puede almacenar más datos debido a que no existe el suficiente espacio continuo para formar un nuevo bloque de memoria. El solicitar más memoria puede ser muy costoso en términos de desempeño, lo que da origen a la recomendación de usar el <em>Heap</em> lo menos posible.</p>
</div>
<div class="paragraph">
<p>El sistema operativo otorga bloques de memoria para los programas, pero no tiene control sobre cómo los programas usan la memoria asignada. Lo único que conoce es que la región de memoria está siendo utilizada por un programa y si otro programa necesita más bloques de memoria, el sistema operativo debe buscar un espacio libre en otro sector. Como la memoria disponible es un recurso limitado, los sistemas operativos modernos tienen mecanismos para abordar la falta de memoria y reemplazarla con espacio en el disco, como si fuera memoria adicional. Por ejemplo en sistemas Linux se conoce como partición "Swap". Este concepto se conoce como "Memoria Virtual" y es una ilusión creada por el sistema operativo para aparentar tener más memoria de la disponible físicamente.</p>
</div>
<div class="paragraph">
<p>Depender del almacenamiento como memoria adicional es más lento que utilizar la memoria <em>RAM</em>, por lo que se debe utilizar este mecanismo con cautela. A pesar de que actualmente existe una cantidad gigante de almacenamiento, en comparación con la década de los 90s, el criterio de desempeño sigue siendo importante. La memoria puede ser un cuello de botella, aún considerando el poder de las <em>CPU</em> actuales, ya que obtener datos de la memoria tiene un costo de tiempo considerable, para esto los fabricantes de procesadores han elaborado lo que se conoce como <em>Cache</em>, el cual es como una memoria pequeña dedicada dentro del procesador, el cual tiene una copia de una región de la memoria, permitiendo a la <em>CPU</em> obtener datos para sus operaciones sin pasar por la memoria principal, pero la memoria principal será utilizada si el dato no está presente en el <em>Cache</em>. La labor de decidir que región de la memoria se almacena en el <em>Cache</em> depende del hardware y no del sistema operativo.</p>
</div>
<div class="paragraph">
<p>El desarrollador tiene la responsabilidad de utilizar estructuras de datos y la memoria adecuadamente para tengan mayor probabilidad de ser transferidas a <em>Cache</em>, permitiendo mayor velocidad de lectura y escritura por que está más cerca de la <em>CPU</em>, lo que se conoce como localidad (locality).</p>
</div>
<div class="paragraph">
<p>Entonces la pila es una estructura de datos adecuada para almacenar los datos de forma compacta y ordenada. Cada vez que un programa declara una variable, su valor es apilado en la región de memoria asignada. Un registro en la <em>CPU</em> almacena el puntero de la pila que indica el dato superior (el registro permite obtener el puntero sin ir a buscar en memoria o cache). Esto hace que las operaciones en el <em>Stack</em> sean muy rápidas gracias al puntero de direcciones. Comunmente solo basta con sumar uno a la posición y se tendrá el siguiente espacio de memoria disponible. Esta facilidad y velocidad de uso contratasta con el <em>Heap</em>, el cual no es tan rápido ni sencillo de utilizar.</p>
</div>
<div class="paragraph">
<p>Las limitaciones de la pila (<em>Stack</em>) está en que no es muy flexible para crecer o reducir dinámicamente su tamaño, es por esto la importancia de tener una buena gestión de memoria, compactando los datos y especificando sus tipos adecuadamente para que los compiladores organicen los datos de forma eficiente y predecible en el <em>Stack</em>. Además el <em>Stack</em> opera en un solo hilo, dando una limitación cuando se intenta compartir memoria entre hilos. Este tipo de limitaciones son solucionadas por el <em>Heap</em>.</p>
</div>
<iframe width="100%" height="415" src="https://www.youtube.com/embed/N3o5yHYLviQ?si=w6iHYaAtTPECO3qO" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
<div class="sect2">
<h3 id="montículo-heap"><a class="anchor" href="#montículo-heap"></a>Montículo (Heap)</h3>
<div class="paragraph">
<p>El montículo (heap), también conocido como "almacenamiento libre". Es una estructura dinámica de datos o área de memoria para lograr asignación dinámica de memoria durante la ejecución de un programa. Permitiendo asignar memoria y liberarla de forma flexible, según sea necesario.</p>
</div>
<div class="paragraph">
<p>La gestión de memoria dinámica requiere de dos tipos de operaciones; la petición y la liberación de memoria. El ciclo es sencillo, cuando se precisa almacenar un nuevo dato, se solicita tanta memoria en bytes como sea necesaria, y una vez que ese dato ya no se necesita la memoria se devuelve para poder ser reutilizada. Este esquema se conoce como "gestión explícita de memoria" pues requiere ejecutar una operación para pedir la memoria y otra para liberarla (Universidad Carlos III de Madrid, s.f.). En el lenguaje C estas funciones son: <code>malloc, calloc, free y realloc</code>.</p>
</div>
<div class="paragraph">
<p>El <em>Heap</em> es necesario debido a que el <em>Stack</em> si bien permite almacenar los datos de forma compacta y mejorar el desempeño, tiene limitaciones debido a que el <em>Stack</em> no permite acomodar dinámicamente los datos. Por ejemplo en un arreglo con elementos definidos no permite añadir nuevos, solo sobre escribirlos. Esto significa que puede gatillar un error de desbordamiento (Stack Overflow) si se intenta añadir más elementos de lo originalmente definido. El <em>Heap</em> permite solicitar memoria virtualmente ilimitada, utilizando llamadas al sistema, lo que permite al <em>Heap</em> almacenar grandes cantidades de datos. Esto trae la necesidad de administrar manualmente la memoria asignada (en los lenguajes de programación de sistemas). Es común la estrategia de almacenar solamente los punteros de memoria (direcciones de memoria, memory addresses) en el <em>Stack</em> y los datos asociados a dichos punteros en el <em>Heap</em>. Un puntero solo representa una dirección de memoria y no contiene la información ni los datos del largo o tamaño de los datos.</p>
</div>
<div class="sect3">
<h4 id="es-posible-la-fragmentación-en-el-heap"><a class="anchor" href="#es-posible-la-fragmentación-en-el-heap"></a>¿Es posible la fragmentación en el <em>Heap</em>?</h4>
<div class="paragraph">
<p>Con el <em>Stack</em> sabemos que existe la fragmentación externa, donde se requiere más bloques de memoria a pesar de que se tiene memoria disponible, debido a la no compactación y desorganización de los datos. La forma de organización del <em>Stack</em> (LIFO) permite mitigar la fragmentación si se utiliza una buena gestión de memoria. Con el <em>Heap</em> no es posible evitar la fragmentación debido a que no tiene un comportamiendo predecible que garantice que los datos estén compactados y ordenados. El <em>Heap</em> no hay garantías de que los elementos serán removidos en un orden específico ni que estén ordenados de forma compactada. Es decir el <em>Heap</em> requiere tiempo de procesamiento variable debido a que los datos almacenados pueden ser de distinto tamaño, necesitando de tiempos variables para su procesamiento.</p>
</div>
<div class="paragraph">
<p>Para mitigar esta fragmentación, en el <em>Heap</em> es necesario verificar si existen agujeros en los bloques de memoria previamente asignados, para evitar realizar una llamada al sistema y reutilizar la memoria disponible. Para esto el <em>Heap</em> recurre a tres estrategias principales.</p>
</div>
<div class="paragraph">
<p>Una estrategia encontrar el primer agujero disponible con la capacidad para almacenar el dato (first fit). Es la más rápida pero no reduce la fragmentación. La segunda es encontrar el agujero lo más pequeño posible que permita almacenar el valor (best fit) y finalmente encontrar cualquier agujero disponible con la capacidad más grande que permita almacenar el dato (worst fit). Ambas podrían reducir la fragmentación pero no son las más rápidas. El uso de estas estrategias no evitan la fragmentación y la elección depende de factores como la rapidez y los pros y contras de cada solución.</p>
</div>
</div>
<div class="sect3">
<h4 id="listas-enlazadas-en-el-heap"><a class="anchor" href="#listas-enlazadas-en-el-heap"></a>Listas enlazadas en el Heap</h4>
<div class="paragraph">
<p>El <em>Heap</em> no resuelve el problema de sobre escribir elementos de un arreglo. Para esto se utilizan estructuras de datos como listas enlazadas de punteros. Donde se tienen nodos que mantienen un puntero asociado al siguiente nodo. Es decir se crea un nuevo nodo (asignando memoria en el <em>Heap</em>) y se añade a la lista, modificando el elemento anterior con el puntero al nuevo nodo. Lo que soluciona esta estrategia es que no se necesitan bloques continuos en la memoria. El principal problema es que los nodos distribuidos por la memoria tienen menos probabilidad de almacenamiento en caché del <em>CPU</em>. Por lo que se debe priorizar compactar los datos.</p>
</div>
</div>
<div class="sect3">
<h4 id="llamadas-al-sistema"><a class="anchor" href="#llamadas-al-sistema"></a>Llamadas al Sistema</h4>
<div class="paragraph">
<p>Por temas de seguridad el sistema operativo no permite acceder directamente al hardware. Por lo que para solicitar recursos los programas deben realizar llamadas al sistema operativo.</p>
</div>
<div class="paragraph">
<p>El siguiente programa en C muestra un "hola mundo" tradicional.</p>
</div>
<div class="listingblock">
<div class="title">Hola mundo en C</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;stdio.h&gt;

int main() {

    // Mostramos el mensaje con printf
    printf("¡Sistemas Operativos!");

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>printf</code> (print format) es una abstracción, una capa a la llamada del sistema
que le dice al sistema operativo que muestre el mensaje en la salida estándar. Esta función formatea el texto para ser finalmente invocada la función <a href="https://courses.cs.umbc.edu/undergraduate/313/spring05/burt_katz/lectures/Lect07/systemCalls.html">write</a> que eventualmente llama a la función <code>syscall</code> con los datos respectivos.</p>
</div>
<div class="paragraph">
<p>Estos son mecanismos de bajo nivel utilizados para estandarizar el acceso a archivos, memoria y otros recursos del sistema, con el fin de permitir la interoperabilidad de forma controlada, lo que asegura la integridad del sistema. Debido a eso, el acceso a los recursos del sistema es lo que llamamos acceso privilegiado y solo puede ser realizado por el sistema operativo. El programa de usuario solicita que el sistema operativo proporcione ese acceso a través de un servicio bien definido. Entonces, asumiendo que el servicio se haya solicitado correctamente, se proporcionará dicho servicio (Burt K, s.f.).</p>
</div>
</div>
<div class="sect3">
<h4 id="coste-de-las-llamadas-a-sistema"><a class="anchor" href="#coste-de-las-llamadas-a-sistema"></a>Coste de las llamadas a sistema</h4>
<div class="paragraph">
<p>Lo importante a destacar de las llamadas al sistema es que tienen un costo en términos de desempeño. Cuando un programa se ejecuta el proceso asociado tiene un estado en los registros de la <em>CPU</em> (El Program Counter, entre otros). Como el sistema operativo debe administrar diferentes procesos, debe guardar el estado en memoria de cada uno. Es como si tomara una fotografía de la información (El contexto de ejecución, execution context) de cada proceso y lo almacenara en memoria para ser obtenido luego de ejecutar la operación solicitada. El constante cambio entre los diferentes contextos de proceso se conoce como "cambio de contexto" (context switch).</p>
</div>
<div class="paragraph">
<p>Se podría resumir en las siguientes etapas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El proceso es iniciado.</p>
</li>
<li>
<p>El proceso ejecuta una llamada al sistema (syscall).</p>
</li>
<li>
<p>El sistema operativo guarda el estado en memoria del proceso.</p>
</li>
<li>
<p>El sistema operativo ejecuta la llamada de sistema.</p>
</li>
<li>
<p>El sistema operativo carga el proceso y le entrega el resultado de la llamada al sistema.</p>
</li>
<li>
<p>El sistema operativo cambia de contexto a otro proceso que solicite otra llamada al sistema.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="el-heap-es-más-lento-que-el-stack"><a class="anchor" href="#el-heap-es-más-lento-que-el-stack"></a>¿El Heap es más lento que el Stack?</h4>
<div class="paragraph">
<p>Como se puede apreciar todas las etapas de gestión de procesos del sistema operativo toman tiempo, recursos y perjudican el desempeño. Cuando un proceso requiere más memoria, se debe utilizar una llamada al sistema. La memoria asignada al <em>Stack</em> está predefinida al iniciar el proceso, por lo que no requiere solicitar más memoria al sistema operativo utilizando llamadas de sistema. El sistema operativo puede necesitar más tiempo en encontrar secciones de memoria disponible para el <em>Heap</em>, por lo que puede haber penalizaciones de tiempo y en el peor de los casos disminuir el desempeño de los programas, causando lentitud en los mismos. Pero esto no significa que usar <em>Heap</em> sea más lento que usar el <em>Stack</em>. Lo que causa lentitud es todo el proceso de asignación de memoria, pero una vez que ya está asignada y con técnicas de gestión de recursos como el caché y estructuras de datos eficientes, utilizar el <em>Heap</em> puede ser tan rápido como usar el <em>Stack</em>.</p>
</div>
<iframe width="100%" height="415" src="https://www.youtube.com/embed/ioJkA7Mw2-U?si=xfbbWP1fEZm_LIoy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
</div>
<div class="sect2">
<h3 id="alu"><a class="anchor" href="#alu"></a>ALU</h3>
<div class="paragraph">
<p>Una unidad aritmética lógica (Arithmetic Logic Unit) toma valores de entrada (OPERANDS) y códigos de operación (OP_CODES) y a través de circuitería (Adder, Subtracter, Incrementer, Decrementer, Decoder, entre otras) y compuertas lógicas (XOR, AND, OR, NOT, entre otras), determina la operación que se debe realizar con esos valores. Finalmente retorna el resultado (Result) de la operación junto a información adicional (Si fue negativo, cero o hubo un desbordamiento).</p>
</div>
<iframe width="100%" height="415" src="https://www.youtube.com/embed/HjneAhCy2N4?si=cYES5pjSdOP2DIln" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
</div>
</div>
<div class="sect1">
<h2 id="el-ciclo-de-instrucción"><a class="anchor" href="#el-ciclo-de-instrucción"></a>El Ciclo de Instrucción</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Una instrucción en el procesador tiene un ciclo de obtener, decodificar y ejecutar.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El procesador utiliza la posición de puntero almacenada en el <code>PC</code> (Program Counter) para leer la siguiente instrucción a procesar desde la memoria.</p>
</li>
<li>
<p>Luego esta instrucción es decodificada. Obteniendo los registros correspondientes.</p>
</li>
<li>
<p>Finalmente se envía a la cadena de ejecución, la cual depende de cada procesador (por ejemplo para arquitecturas <a href="https://es.wikipedia.org/wiki/RISC-V">RISC-V</a> son 5 etapas). Acá es utilizada la <em>ALU</em> para obtener el resultado.</p>
</li>
<li>
<p>El ciclo se repite modificando el <code>PC</code> para obtener la siguiente instrucción a procesar. Un procesador puede ejecutar millones de instrucciones por segundo.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/instruction-cycle.png" alt="instruction cycle">
</div>
<div class="title">Figure 1. Ciclo de Instrucción, fuente: John Kubiatowicz CS162 Lecture 2, 2020.</div>
</div>
<div class="paragraph">
<p>El siguiente video muestran el funcionamiento
de las compuertas lógicas y la ALU.</p>
</div>
<iframe width="100%" height="415" src="https://www.youtube.com/embed/-ZTekGoR8uQ?si=9yESp9wBXkL3UODs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
</div>
<div class="sect1">
<h2 id="actividades"><a class="anchor" href="#actividades"></a>Actividades</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En esta actividad se practicará la creación de scripts con Bash, las diferencias entre root (administrador) y usuario común y la instalación de programas en Debian Linux con el gestor de paquetes <code>apt</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instalar Debian en una máquina virtual</p>
</li>
<li>
<p>Instalar editor <em>Gedit</em> (<code># apt install gedit -y</code>).</p>
</li>
<li>
<p>Seleccionar un ejercicio resuelto de la sección 2.30 del libro Enrique Soriano, crear un archivo y ejecutarlo con (<code>$ chmod +x</code>).</p>
</li>
<li>
<p>(Opcional) Realizar los ejercicios no resueltos de la sección 2.31 del libro Enrique Soriano. Ejercicio 7 y Ejercicio 11.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="foro"><a class="anchor" href="#foro"></a>Foro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En un mínimo de 150 palabras y un máximo de 350 palabras. Responda lo siguiente:</p>
</div>
<div class="paragraph">
<p><strong>¿Por qué un Hilo (Thread) es una abstracción de una CPU?</strong></p>
</div>
<div class="paragraph">
<p>Incluya introducción, desarrollo, conclusión y referencias bibliográficas (al menos 2) formato APA 7. Comente la respuesta de dos de sus compañeros (con referencias en APA 7).</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="../introduction/roles.html">¿Qué Roles Tiene un Sistema Operativo?</a></span>
  <span class="next"><a href="process.html">Procesos</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async src="../search-index.js"></script>
  </body>
</html>
