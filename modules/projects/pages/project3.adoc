= Proyecto 3: Servidor de Videojuegos

La empresa _Waripolo Games_ le ha contratado para elaborar el servidor de su próximo videojuego
multijugador. El juego es el conocido _Cachipún_, pero con la variante _RPSLS_.
El servidor consiste en un programa que utiliza Sockets TCP para recibir peticiones. El cliente
debe conectarse al servidor y enviar instrucciones, mostrando el resultado recibido desde el servidor.

Las reglas son las siguientes:

- (0) Piedra: Destroza tijeras y aplasta al lagarto.
- (1) Papel: Cubre la piedra y refuta a Spock.
- (2) Tijeras: Corta el papel y decapita al lagarto.
- (3) Lagarto: Come papel y envenena a Spock.
- (4) Spock: Vaporiza la piedra y destroza las tijeras.

Los estados del resultado son los siguientes:

- (0) Empate: Se debe jugar de nuevo. 
- (1) X: Pierde 
- (2) O: Gana 

.Tabla de Reglas
|====
|ID|Piedra|Papel|Tijeras|Lagarto|Spock
|Piedra| Empate | X | O | O | X
|Papel| O | Empate | X | X | O
|Tijeras| X | O | Empate | O | X
|Lagarto| X | O | X | Empate | O
|Spock| O | X | O | X | Empate
|====

Juego de ejemplo: https://juanma1313.github.io/spock-game/

Las reglas se pueden poner en un diccionario con un arreglo de opciones.

[source, elixir]
----
reglas = %{
  0 => [0, 1, 2, 2, 1],
  1 => [2, 0, 1, 1, 2],
  2 => [1, 2, 0, 2, 1],
  3 => [1, 2, 1, 0, 2],
  4 => [2, 1, 2, 1, 0]
}

jugador1 = 0
jugador2 = 1

resultado = reglas
            |> Map.get(jugador2)
            |> Enum.at(jugador1)
            
case resultado do
  0 -> "Empate"
  1 -> "Gana Jugador 1"
  2 -> "Gana Jugador 2"
end
|> IO.inspect()
----

== Ejemplo de Funcionamiento

. El servidor se inicia y espera instrucciones en un puerto determinado (6502).
. El cliente se conecta al servidor como jugador 1.
. Un nuevo cliente se conecta al servidor como jugador 2.
. El servidor solicita al jugador 1 su movimiento (número del 1 al 5).
. El servidor solicita al jugador 2 su movimiento (número del 1 al 5).
. Si se ingresa un valor no válido, se considera empate y el servidor vuelve a pedir los movimientos de cada jugador.
. El servidor anuncia que jugador ganó según las reglas y solicita nuevamente los movimientos de cada jugador. 

[source, text]
----
$ ./server &
$ ./client 127.0.0.1 6502
$ > servidor: Bienvenido jugador 1
$ > servidor: Esperando a jugador 2
$ > servidor: Jugador 2 conectado
$ > servidor: Ingrese su movimiento (1 - 5)
$ > 1
$ > servidor: Haz ganado.
$ > servidor: Ingrese su movimiento (1 - 5)
$ > 2
$ > servidor: Empate
$ > servidor: Ingrese su movimiento (1 - 5)
$ > 6
$ > servidor: Empate
$ > servidor: Ingrese su movimiento (1 - 5)
$ > 3
$ > servidor: Perdiste
$ > servidor: Ingrese su movimiento (1 - 5)
$ > servidor: Jugador 2 desconectado
$ > servidor: Esperando a jugador 2
...
----

== Requisitos

- Servidor y Cliente hecho en Elixir
- Proyecto Individual.
- El cliente debe poder interactuar con cualquier servidor que implemente el protocolo.
- El servidor debe poder interactuar con cualquier cliente que implemente el protocolo.

== Objetivos de Aprendizaje

Al realizar este proyecto el alumno podrá profundizar en sistemas de comunicación
inter procesos (IPC) como el uso de sockets, programación concurrente y patrón de productor-consumidor.
