= Strings 


Los Strings o cadenas de caracteres en _Ada_ est√°n condicionadas por la codificaci√≥n de caracteres.

- `String`: 256 caracteres disponibles en la codificaci√≥n _Latin-1_ (8 bit).
- `Wide_String`: 65536 caracteres disponibles (16 bit).
- `Wide_Wide_String`: 1114112 caracteres disponibles (code points de 32 bit). Ideal para almacenar emojis (UTF-8).

[source, ada]
----
type String is
  array (Positive range <>) of Character;

type Wide_String is
  array (Positive range <>) of Wide_Character;

type Wide_Wide_String is
  array (Positive range <>) of
    Wide_Wide_Character;
----

Cada una tiene su procedimiento de salida asociado. Si bien `Wide_Wide_String` tiene un amplio abanico
de caracteres posibles, no es lo suficientemente flexible para todo _Unicode_, ya que el est√°ndar _Unicode_
no solo manipula caracteres, tambi√©n la combinaci√≥n de los mismos. Para trabajar con _Unicode_ se recomienda
el uso de una biblioteca externa como https://github.com/AdaCore/VSS[VSS].

[source, ada]
----
with Ada.Text_IO;
with Ada.Wide_Text_IO;
with Ada.Wide_Wide_Text_IO;

procedure Strings is
   √±and√∫ : constant String := "√ëand√∫";
   œÄ : constant := 3.14;
   hello : constant Wide_String := "–ü—Ä–∏–≤—ñ—Ç";
   fire : constant Wide_Wide_String := "üî•";
begin
   
   Ada.Text_IO.Put_Line(√±and√∫);
   Ada.Text_IO.Put_Line(œÄ'Image);
   Ada.Wide_Text_IO.Put_Line (hello);
   Ada.Wide_Wide_Text_IO.Put_Line (fire);

end Strings;
----

Sin embargo el c√≥digo anterior no compilar√°, ya que es necesario configurar 
el proyecto para que soporte _Unicode_. Se debe editar el archivo de proyecto `gpr`, 
en este caso `strings.gpr` y a√±adir la opci√≥n `-gnatW8` para que autorice el uso
de caracteres _Unicode_.

[source, ada]
----
package Compiler is
      for Default_Switches ("Ada") use Strings_Config.Ada_Compiler_Switches & ("-gnatW8");
end Compiler;
----

Una vez configurado se puede ejecutar normalmente.

[source, bash]
----
$ alr run
----

[source, text]
----
‚úì Build finished successfully in 7.82 seconds.
√±and√∫
 3.14000000000000000E+00
–ü—Ä–∏–≤—ñ—Ç
üî•
----

[NOTE]
====
Se puede notar el uso de identificadores con caracteres especiales como `√±and√∫`. _Ada_ soporta
identificadores dentro del rango de 16 bit (Wide_String), es decir puede ser con letras, pero
no ser un emoji.
====

[CAUTION]
====
Se recomienda usar solamente _ASCII_ para identificadores, ya que facilita la programaci√≥n entre 
personas con distintos idiomas y configuraci√≥n de teclado. 
====

== Caracteres

Los strings son arreglos compuestos por caracteres. El cual es un s√≠mbolo que √©sta definido por la codificaci√≥n, 
al igual que el string. Est√° delimitado por dos comillas simples (`''`).

- `Character`: 256 caracteres disponibles en la codificaci√≥n _Latin-1_ (8 bit).
- `Wide_Character`: 65536 caracteres disponibles (16 bit).
- `Wide_Wide_Character`: 1114112 caracteres disponibles (code points de 32 bit).

[source, ada]
----
type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M');
----

== Concatenaci√≥n

En muchos lenguajes de programaci√≥n se tiene un mecanismo que permite
crear strings multil√≠nea. En _Ada_ esto no es posible, sin embargo, se puede lograr el efecto de m√∫ltiples l√≠neas usando secuencias de escape para representar caracteres de nueva l√≠nea dentro de una cadena o definiendo m√∫ltiples cadenas concatenadas con el operador `&`.

[source, ada]
----
with Ada.Text_IO;

procedure Main is
   My_String : constant String := "Primera l√≠nea" & ASCII.LF 
                                 & "Segunda l√≠nea" & ASCII.LF 
                                 & "Tercera l√≠nea";

begin
   Ada.Text_IO.Put_Line(My_String);
end Main;
----

== Unbounded String

Una vez definido un string su tama√±o es est√°tico. Si se desea tener un tama√±o din√°mico
se debe usar el tipo _Unbounded String_ que permite aumentar su tama√±o. Un dato del tipo `Unbounded_String`
representa un `String` que va desde 1 caracter y de un largo variable entre 0 y el m√°ximo de los n√∫meros naturales (`Narutal'Last`).

Los `Unbounded_String` a diferencia de los strings nativos no son arreglos de caracters, eso quiere decir que no se les puede aplicar el atributo `'Range` ni los parentesis para indexar. En vez de eso son un tipo privado que tiene en su paquete (el `Ada.Strings.Unbounded`) todas las operaciones necesarias para reemplazar caracteres (`Replace_Element`), convertir a string (`To_String`) y desde string (`To_Unbounded_String`), concatenar (operador `&`), reemplazar subcadenas del `Unbounded_String` por otras (`Replace_Slice`), buscar subcadenas (`Index`), etc.

La ventaja de un `Unbounded_String` es que puede crecer y decrecer sin l√≠mite (o sin otro l√≠mite que la memoria disponible). 

[source, ada]
----
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;

procedure Ejemplo_Unbounded_String is
   -- Declaraci√≥n de un Unbounded_String
   Mi_Cadena : Unbounded_String;
   Otra_Cadena : Unbounded_String;

   --  Declaraci√≥n de una cadena regular
   Mi_String : String := "Hola";

begin
   -- Conversi√≥n de String a Unbounded_String
   Mi_Cadena := To_Unbounded_String(Mi_String);
   Put_Line("Mi_Cadena (inicial): " & To_String(Mi_Cadena));

   --  Concatenaci√≥n con Unbounded_String
   Otra_Cadena := Mi_Cadena & " Mundo";
   Put_Line("Otra_Cadena (concatenada): " & To_String(Otra_Cadena));

   -- Concatenaci√≥n con String
   Mi_Cadena := Mi_Cadena & " ";
   Mi_Cadena := Mi_Cadena & To_Unbounded_String("de nuevo");
   Put_Line("Mi_Cadena (concatenada): " & To_String(Mi_Cadena));

   --  Longitud de la cadena
   Put_Line("Longitud de Mi_Cadena: " & Integer'Image(Length(Mi_Cadena)));

   --  Acceso a un caracter (necesita conversi√≥n a String)
   if Length(Mi_Cadena) > 0 then
       Put_Line("Primer caracter de Mi_Cadena: " & Mi_Cadena'image(1));
       Put_Line("Primer caracter de Mi_Cadena (usando To_String): " & To_String(Mi_Cadena)(1));
   end if;


   --  Reemplazo de un caracter
   Replace_Element(Mi_Cadena, 1, 'h');
   Put_Line("Mi_Cadena (despu√©s de reemplazar): " & To_String(Mi_Cadena));

   --  Extracci√≥n de una subcadena (Slice)
   declare
       Sub_Cadena : Unbounded_String := Slice(Mi_Cadena, 3, 6);
   begin
      Put_Line("Sub_Cadena: " & To_String(Sub_Cadena));
   end;
   
end Ejemplo_Unbounded_String;
----



== ¬øPor qu√© tantos tipos de String?

A diferencia de otros lenguajes que tienen un solo tipo de string para todos los casos.
Es importante recalcar que _Ada_ es un lenguaje pensado para sistemas cr√≠ticos
donde la gesti√≥n de memoria es de suma importancia para evitar errores imprevistos.
El tener una definici√≥n exacta del tama√±o de un string, permite un manejo granular
y seguro de los tipos y tama√±os de datos.

Las formas restringidas (`String`) pueden lanzar excepciones al alcanzar sus l√≠mites (`Constraint_Error`).
Y las formas din√°micas (`Unbounded_String`) pueden alcanzar l√≠mites de memoria (_heap_) que no son deseables en aplicaciones de uso cr√≠tico.

Sin embargo tener tantos tipos de datos puede causar problemas de complejidad
combinatoria (muchos tipos de datos y su manejo de memoria respectivo). Es por esto que actualmente la comunidad est√° pensando https://github.com/Ada-Rapporteur-Group/User-Community-Input/issues/40[alternativas de soluci√≥n].

Por el momento se recomienda usar una https://github.com/AdaCore/VSS[biblioteca externa como VSS] para cuando
el uso de `String` y `Unbounded_String` no sea apropiado.

== M√°s Info

Para mayor informaci√≥n se puede revisar el https://learn.adacore.com/courses/advanced-ada/parts/data_types/strings.html[manual avanzado de strings en Ada].